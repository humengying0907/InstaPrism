---
title: Tutorial of fastBP
author: Mengying Hu
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    theme: lumen
    highlight: default
    toc: true
    toc_depth: 2
toc-title: "Table of Contents"
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction
**fastBP** is R package to deconvolute cellular proportion and gene expression in bulk RNA-Seq data. It is based on a Bayesian inference model from BayesPrism. **fastBP** provides fast implementation of the deconvolution module from BayesPrism: it replaces the time-consuming gibbs sampling steps in BayesPrism with a fixed-point algorithm that greatly accelerated the calculation speed while maintaining similar performance as BayesPrism.  \

In this tutorial, we provide three examples of running fastBP and compare the results with BayesPrism.

## Getting started
We recommend the readers to read through the tutorial of BayePrism before running our examples. **fastBP** also provide the option to run deconvolution on bulk RNA-seq without the need of installing BayesPrism package. 
```{r setup}
library(fastBP)
```

## Example 1: deconvolution on a small simulated dataset
\

#### Step 1. Create simulated single cell and bulk expression data
The following lines simulate bulk and single-cell expression, as well as marker genes and true proportions that can be used as an example of deconvolution using the simulation model the **BisqueRNA** package. 

```{r,eval=FALSE}
library(Biobase)
library(BisqueRNA)
cell.types <- c("Neurons", "Astrocytes", "Oligodendrocytes", "Microglia", "Endothelial Cells","others")
avg.props <- c(.5, .2, .15, .07, .03,.05)
sim.data <- SimulateData(n.ind=20, n.genes=1000, n.cells=500, cell.types=cell.types, avg.props=avg.props)
```

sim.data contains the following objects:

* A 1000 $\times$ 10000 single-cell expression object for 20 individuals, with cells annotated with inidivual ID and cell type labels.
* A 1000 $\times$ 20 bulk expression object for 20 individuals.
* A 6 $\times$ 20 matrix indicating cellular proportions for 20 individuals.
* A dataframe indicating marker genes for each cell type

Alternatively, readers can load the example simulated data directly from the **fastBP** package.
```{r}
data("sim.data")
```
\

#### Step 2. Prepare input for fastBP and BayesPrism
**fastBP** takes the same input format as BayesPrism:

* a single-cell expression data as prior information
* a bulk expression to run deconvolution
* a character vector indicating cell types of each cell from the scRNA data
* a character vector indicating cell states of each cell from the scRNA data

In real practice, cell.state.labels usually denote different cell states from a same given cell type. For example, malignant cells can be subclustered by different patients to denote different malignant states. With the *sim.data* we created above, we will generate some artificial cell state labels for *Neurons* given individual IDs.

```{r,include=FALSE}
library(dplyr)
library(tidyr)
library(Biobase)
library(ggplot2)
library(ggpmisc)
```

```{r}
sc.eset <- sim.data$sc.eset
bulk.eset <- sim.data$bulk.eset

sc_Expr = exprs(sc.eset)
sc_Expr = apply(sc_Expr,2,function(x)((x/sum(x))*1e+05)) 

bulk_Expr = exprs(bulk.eset)
bulk_Expr = apply(bulk_Expr,2,function(x)((x/sum(x))*1e+06)) 

cell_type_labels=sc.eset@phenoData@data[["cellType"]]

# create artifical cell-state labels for Neuron cells: Neuron_A, Neuron_B, Neuron_C
Neurons_states=names(table(sc.eset@phenoData@data$SubjectName))
names(Neurons_states)=c(rep("A",8),rep("B",6),rep("C",6))

cell_state_labels=ifelse(sc.eset@phenoData@data[["cellType"]]=='Neurons',paste0('Neurons_sub',names(Neurons_states)[match(sc.eset@phenoData@data$SubjectName,Neurons_states)]),sc.eset@phenoData@data[["cellType"]])

table(cell_state_labels)
```
\

#### Step 3. Run deconvolution with fastBP and BayesPrism 
\ 
We first consider a simple implementation where we use prior information from the scRNA Seq directly, without the need to update reference.

i. Run fastBP with raw input. In this mode, users don't need to have BayesPrism installed.
```{r,results='hide',message=FALSE}
start.time = Sys.time()
fastbp.res = fastBP(input_type = 'raw',sc_Expr = sc_Expr,bulk_Expr = bulk_Expr,
                    cell.type.labels = cell_type_labels, cell.state.labels = cell_state_labels,
                    update=F,key='Neurons')
end.time=Sys.time()
fastbp_mode1_running_time = difftime(end.time, start.time,units = 'secs') %>% as.numeric()
```

ii. Run fastBP with a Prism Object as input. 
```{r,results='hide',message=FALSE}
library(BayesPrism)
start.time = Sys.time()
bp.obj = new.prism(reference = t(sc_Expr),input.type = 'count.matrix',
                   cell.type.labels = cell_type_labels, cell.state.labels = cell_state_labels,
                   key = 'Neurons',mixture = t(bulk_Expr))
fastbp.res2 = fastBP(input_type = 'prism',prismObj = bp.obj,update=F)
end.time=Sys.time()
fastbp_mode2_running_time = difftime(end.time, start.time,units = 'secs') %>% as.numeric()
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;With update = F, fastBP function returns the following objects:

* Post.ini.cs: posterior information for cell.states
    + Z: a three dimension array indicating gene expression of each cell.state in different individual
    + theta: cell.state fraction estimates for each individual
* Post.ini.ct: posterior information for cell.types
    + Z: a three dimension array indicating gene expression of each cell.types in different individual
    + theta: cell.types fraction estimates for each individual
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that fastBP with both input types produce the same results
```{r}
all.equal(fastbp.res,fastbp.res2)
```


iii. Run BayesPrism 
```{r,eval=FALSE}
start.time = Sys.time()
bp.res = run.prism(bp.obj,update.gibbs = F)
end.time=Sys.time()
bp_running_time = difftime(end.time, start.time,units = 'secs') %>% as.numeric()
```
\ 


```{r,include=FALSE}
load('../../support/tmp.RData')
```

 
#### Step 4. Evaluate deconvolution results of fastBP and BayesPrism 

* deconvolution performance of fastBP

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fastBP acurately predicts cellular proportions from sim.data

```{r,fig.align='center',fig.width=10,fig.height=2.35}
deconv_performance_plot(est = fastbp.res$Post.ini.ct$theta,true = sim.data$props,title = 'fastBP performance on sim.data',nrow=1)
```

* compare cell type fraction estimates from fastBP and BayesPrism

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cell.type estimation from both methods are highly correlated 

```{r}
corr=cor(t(fastbp.res$Post.ini.ct$theta),bp.res@posterior.initial.cellType@theta)
diag(corr)
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; note that we did not include a cell.state comparison here because with artificial cell.state.labels imposed on cells that are not intrinsically distinguishable, it will generate bias on the cell.state estimates

* running time comparison

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fastBP significantly accelerates the deconvolution speed in either modes.

```{r,fig.align='center',fig.width=4.5,fig.height=2.35}
rt=data.frame(method=c('fastBP.raw.mode','fastBP.prism.mode','BayesPrism'),
              time=c(fastbp_mode1_running_time,fastbp_mode2_running_time,bp_running_time))
ggplot(rt,aes(method,time))+
  geom_bar(stat="identity",fill='grey')+
  theme_bw()+
  ylab('time (secs)')
```

## Example 2: deconvolution on the tuturial data from BayesPrism

## Example 3: deconvolution on heterogeneously simulated bulk data




