---
title: Tutorial of InstaPrism
author: Mengying Hu
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    theme: lumen
    highlight: default
    toc: true
    toc_depth: 2
toc-title: "Table of Contents"
#vignette: >
#  %\VignetteIndexEntry{Vignette Title}
#  %\VignetteEngine{knitr::rmarkdown}
#  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction
**InstaPrism** is R package to deconvolute cellular proportion and gene expression in bulk RNA-Seq data. It is based on a Bayesian inference model from BayesPrism. **InstaPrism** provides fast implementation of the deconvolution module from BayesPrism: it replaces the time-consuming gibbs sampling steps in BayesPrism with a fixed-point algorithm that greatly accelerated the calculation speed while maintaining similar performance as BayesPrism.  \

In this tutorial, we provide three examples of running InstaPrism and compare the results with BayesPrism.

## Getting started
load **InstaPrism** package \
We recommend the readers to read through the tutorial of BayePrism before running our examples. 
```{r setup}
library(InstaPrism)
```

## Example 1: deconvolution on a small simulated dataset
\

#### Step 1. Create simulated single cell and bulk expression data
The following lines simulate bulk and single-cell expression, as well as marker genes and true proportions that can be used as an example of deconvolution using the simulation model the **BisqueRNA** package. 

```{r,eval=FALSE}
library(Biobase)
library(BisqueRNA)
cell.types <- c("Neurons", "Astrocytes", "Oligodendrocytes", "Microglia", "Endothelial Cells","others")
avg.props <- c(.5, .2, .15, .07, .03,.05)
sim.data <- SimulateData(n.ind=20, n.genes=1000, n.cells=500, cell.types=cell.types, avg.props=avg.props)
```

sim.data contains the following objects:

* A 1000 $\times$ 10000 single-cell expression object for 20 individuals, with cells annotated with inidivual ID and cell type labels.
* A 1000 $\times$ 20 bulk expression object for 20 individuals.
* A 6 $\times$ 20 matrix indicating cellular proportions for 20 individuals.
* A dataframe indicating marker genes for each cell type

Alternatively, readers can load the example simulated data directly from the **InstaPrism** package.
```{r}
data("sim.data")
```
\

#### Step 2. Prepare input for InstaPrism and BayesPrism
**InstaPrism** takes the same input format as BayesPrism:

* a single-cell expression data as prior information
* a bulk expression to run deconvolution
* a character vector indicating cell types of each cell from the scRNA data
* a character vector indicating cell states of each cell from the scRNA data

In real practice, cell.state.labels usually denote different cell states from a same given cell type. For example, malignant cells can be subclustered by different patients to denote different malignant states. With the *sim.data* we created above, we will generate some artificial cell state labels for *Neurons* given individual IDs.


```{r}
library(Biobase)
sc.eset <- sim.data$sc.eset
bulk.eset <- sim.data$bulk.eset

sc_Expr = exprs(sc.eset)
sc_Expr = apply(sc_Expr,2,function(x)((x/sum(x))*1e+05)) 

bulk_Expr = exprs(bulk.eset)
bulk_Expr = apply(bulk_Expr,2,function(x)((x/sum(x))*1e+06)) 

cell_type_labels=sc.eset@phenoData@data[["cellType"]]

# create artifical cell-state labels for Neuron cells: Neuron_A, Neuron_B, Neuron_C
Neurons_states=names(table(sc.eset@phenoData@data$SubjectName))
names(Neurons_states)=c(rep("A",8),rep("B",6),rep("C",6))

cell_state_labels=ifelse(sc.eset@phenoData@data[["cellType"]]=='Neurons',paste0('Neurons_sub',names(Neurons_states)[match(sc.eset@phenoData@data$SubjectName,Neurons_states)]),sc.eset@phenoData@data[["cellType"]])

table(cell_state_labels)
```
\

#### Step 3. Run deconvolution with InstaPrism and BayesPrism 
\ 
We first consider a simple implementation where we use prior information from the scRNA Seq directly, without the need to update reference.

i. Run InstaPrism with raw input. In this mode, users don't need to have BayesPrism installed.
```{r,results='hide',message=FALSE}
start.time = Sys.time()
InstaPrism.res = InstaPrism(input_type = 'raw',sc_Expr = sc_Expr,bulk_Expr = bulk_Expr,
                    cell.type.labels = cell_type_labels, cell.state.labels = cell_state_labels,
                    update=F,key='Neurons')
end.time=Sys.time()
InstaPrism_mode1_running_time = difftime(end.time, start.time,units = 'secs') %>% as.numeric()
```

ii. Run InstaPrism with a Prism Object as input. 
```{r,results='hide',message=FALSE}
library(BayesPrism)
start.time = Sys.time()
bp.obj = new.prism(reference = t(sc_Expr),input.type = 'count.matrix',
                   cell.type.labels = cell_type_labels, cell.state.labels = cell_state_labels,
                   key = 'Neurons',mixture = t(bulk_Expr))
InstaPrism.res2 = InstaPrism(input_type = 'prism',prismObj = bp.obj,update=F)
end.time=Sys.time()
InstaPrism_mode2_running_time = difftime(end.time, start.time,units = 'secs') %>% as.numeric()
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;With update = F, InstaPrism function returns the following objects:

* Post.ini.cs: posterior information for cell.states
    + Z: a three dimension array indicating gene expression of each cell.state in different individual
    + theta: cell.state fraction estimates for each individual
* Post.ini.ct: posterior information for cell.types
    + Z: a three dimension array indicating gene expression of each cell.types in different individual
    + theta: cell.types fraction estimates for each individual
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that InstaPrism with both input types produce the same results
```{r}
all.equal(InstaPrism.res,InstaPrism.res2)
```


iii. Run BayesPrism 
```{r,eval=FALSE}
start.time = Sys.time()
bp.res = run.prism(bp.obj,update.gibbs = F)
end.time=Sys.time()
bp_running_time = difftime(end.time, start.time,units = 'secs') %>% as.numeric()
# save(bp.res,bp_running_time,file='extdata/tutorial_example1/bp.res.initial.RData')
```
\ 


```{r,include=FALSE}
load('extdata/tutorial_example1/bp.res.initial.RData')
```


#### Step 4. Evaluate deconvolution results of InstaPrism and BayesPrism 

* deconvolution performance of InstaPrism

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InstaPrism acurately predicts cellular proportions from sim.data

```{r,fig.align='center',fig.width=10,fig.height=2.35}
deconv_performance_plot(est = InstaPrism.res$Post.ini.ct$theta,true = sim.data$props,title = 'InstaPrism performance on sim.data',nrow=1)
```

* compare cell type fraction estimates from InstaPrism and BayesPrism

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cell.type estimation from both methods are highly correlated 

```{r}
corr=cor(t(InstaPrism.res$Post.ini.ct$theta),bp.res@posterior.initial.cellType@theta)
diag(corr)
```
```{r,fig.align='center',fig.height=3.65,fig.width=4.5}
ComplexHeatmap::Heatmap(corr,show_row_dend = F,show_column_dend = F,column_title = 'BayesPrism',row_title = 'InstaPrism',name='correlation')
```


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; note that we did not include a cell.state comparison here because with artificial cell.state.labels imposed on cells that are not intrinsically distinguishable, it will generate bias on the cell.state estimates

* running time comparison

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstaPrism significantly accelerates the deconvolution speed in either modes.

```{r,fig.align='center',fig.width=4.7,fig.height=2.45}
rt=data.frame(method=c('InstaPrism.raw.mode','InstaPrism.prism.mode','BayesPrism'),
              time=c(InstaPrism_mode1_running_time,InstaPrism_mode2_running_time,bp_running_time))
rt$time=round(rt$time,2)
ggplot(rt,aes(method,time))+
  geom_bar(stat="identity",fill='grey',width = 0.5)+
  theme_bw()+
  ylab('time (secs)')+
  geom_text(aes(label = time), vjust = -0.2)+
  ylim(0,max(rt$time)*1.05)
```

\

#### Step 5 (optional). Run deconvolution with InstaPrism and BayesPrism using the updated reference
We now consider a more advanced deconvolution problem where we want to leverage from the information shared by bulk samples and update the reference matrix accordingly. \

This step is implemented in BayesPrism by setting `update.gibbs = TRUE` in `run.prism()` function, or by calling the `update.theta()` function on the initial deconvoluton object. In **InstaPrism**, we concatenated the `update.theta()` module from BayesPrism and replaced the subsequent Gibbs Sampling step with our fixed-point alogirthm. \
Note that to run deconvolution with the updated reference, users need to have BayesPrism installed. 


i. deconvolution with InstaPrism
```{r,warning=FALSE}
start.time = Sys.time()
InstaPrism.res.updated = InstaPrism(input_type = 'raw',sc_Expr = sc_Expr,bulk_Expr = bulk_Expr,
                    cell.type.labels = cell_type_labels, cell.state.labels = cell_state_labels,
                    update=T,key='Neurons')
end.time=Sys.time()
InstaPrism_updated_running_time = difftime(end.time, start.time,units = 'secs') %>% as.numeric()
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;With update = T, InstaPrism function returns the following objects:

* Post.ini.cs: posterior information for cell.states
    + Z: a three dimension array indicating gene expression of each cell.state in different individual
    + theta: cell.state fraction estimates for each individual
* Post.ini.ct: posterior information for cell.types
    + Z: a three dimension array indicating gene expression of each cell.types in different individual
    + theta: cell.types fraction estimates for each individual
* Post.updated.ct: cell.type fraction estimates using updated reference


ii. deconvolution with BayesPrism
```{r,eval=FALSE}
start.time = Sys.time()
bp.res.updated = run.prism(bp.obj,update.gibbs = T)
# alternatively, run initial theta estimation and updated theta estimation separately
# bp.res = run.prism(bp.obj,update.gibbs = F)
# bp.res.updated = update.theta(bp=bp.res)
end.time=Sys.time()
bp_updated_running_time = difftime(end.time, start.time,units = 'secs') %>% as.numeric()
save(bp.res.updated,bp_updated_running_time,file = 'extdata/tutorial_example1/bp.res.updated.RData')
```

iii. deconvolution results comparison \

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cell.type estimation from both methods are highly correlated 

```{r,include=FALSE}
load('extdata/tutorial_example1/bp.res.updated.RData')
```

```{r}
corr=cor(t(InstaPrism.res.updated$Post.updated.ct),bp.res.updated@posterior.theta_f@theta)
diag(corr)
```
```{r,fig.align='center',fig.height=3.65,fig.width=4.5}
ComplexHeatmap::Heatmap(corr,show_row_dend = F,show_column_dend = F,column_title = 'BayesPrism',row_title = 'InstaPrism',name='correlation')
```

* running time comparison

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstaPrism significantly accelerates the deconvolution speed using the updated reference.

```{r,fig.align='center',fig.width=4.7,fig.height=2.45}
rt=data.frame(method=c('InstaPrism','BayesPrism'),
              time=c(InstaPrism_updated_running_time,bp_updated_running_time))
rt$time=round(rt$time,2)
ggplot(rt,aes(method,time))+
  geom_bar(stat="identity",fill='grey',width = 0.5)+
  theme_bw()+
  ylab('time (secs)')+
  geom_text(aes(label = time), vjust = -0.2)+
  ylim(0,max(rt$time)*1.05)
```


## Example 2: deconvolution on the tutorial data from BayesPrism
\
In this example, we will use the tutorial [data](https://github.com/Danko-Lab/BayesPrism/tree/main/tutorial.dat) provided in BayesPrism and compare the deconvolution results between InstaPrism and BayesPrism. \

i. Run BayesPrism following the [tutorial](https://github.com/Danko-Lab/BayesPrism/blob/main/tutorial_deconvolution.pdf) in BayesPrism. \

Note that it takes more than 6 hours to run the following code from our end (using n.core=16), users can skip the BayesPrism running process by loading our processed results directly. 

```{r,eval=FALSE}
library(BayesPrism)
load('extdata/tutorial_example2/tutorial.gbm.rdata')

sc.stat <- plot.scRNA.outlier(
  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID 
  cell.type.labels=cell.type.labels,
  species="hs", #currently only human(hs) and mouse(mm) annotations are supported
  return.raw=TRUE #return the data used for plotting. 
  #pdf.prefix="gbm.sc.stat" specify pdf.prefix if need to output to pdf
)
bk.stat <- plot.bulk.outlier(
  bulk.input=bk.dat,#make sure the colnames are gene symbol or ENSMEBL ID 
    sc.input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID 
  cell.type.labels=cell.type.labels,
  species="hs", #currently only human(hs) and mouse(mm) annotations are supported
  return.raw=TRUE
  #pdf.prefix="gbm.bk.stat" specify pdf.prefix if need to output to pdf
)

# Filter outlier genes from scRNA-seq data
sc.dat.filtered <- cleanup.genes (input=sc.dat,
                                  input.type="count.matrix",
                                    species="hs", 
                                    gene.group=c( "Rb","Mrp","other_Rb","chrM","MALAT1","chrX","chrY") ,
                                    exp.cells=5)

# Subset protein coding genes
sc.dat.filtered.pc <-  select.gene.type (sc.dat.filtered,
                                        gene.type = "protein_coding")

# construct a prism object
myPrism <- new.prism(
  reference=sc.dat.filtered.pc, 
  mixture=bk.dat,
  input.type="count.matrix", 
  cell.type.labels = cell.type.labels, 
  cell.state.labels = cell.state.labels,
  key="tumor",
  outlier.cut=0.01,
    outlier.fraction=0.1,
)

# run BayesPrism
start.time = Sys.time()
bp.res <- run.prism(prism = myPrism, n.cores=16,update.gibbs=T) # set update.gibbs=T for full comparison between two methods
end.time=Sys.time()
bp_running_time = difftime(end.time, start.time,units = 'mins') %>% as.numeric()
save(bp.res,bp_running_time,file = 'extdata/tutorial_example2/bp.res.RData')

```

Alternatively, users can download the processed results directly from zenodo repository (will update later)
```{r,eval=FALSE}
load('extdata/tutorial_example2/bp.res.RData')
```


ii. Run InstaPrism \

```{r,eval=FALSE}
library(BayesPrism)
start.time = Sys.time()
InstaPrism.res = InstaPrism(input_type = 'prism',prismObj = bp.res@prism,update=T,n.iter = 100,n.core=16)
end.time=Sys.time()
InstaPrism_running_time = difftime(end.time, start.time,units = 'mins') %>% as.numeric()
save(InstaPrism.res,InstaPrism_running_time,file = 'extdata/tutorial_example2/InstaPrism.res.RData')
```


## Example 3: deconvolution on heterogeneously simulated bulk data




